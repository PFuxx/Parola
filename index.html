<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8" />
  <title>Parola – vizuális prototípus</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --panel-bg: rgba(20, 20, 20, 0.85);
      --panel-border: rgba(255,255,255,0.12);
      --text: #f2f2f2;
      --muted: #8b8b8b;
      --node-normal: #ffffff;
      --node-stroke: #111;
      --node-winner: #39d353;
      --node-dead: #ff4d4f;
      --node-excl: #9e9e9e;
      --node-maybe: #d5b8ff;
      --line: #ffffff;

      /* Szabály-színek: világos, jól olvasható árnyalatok */
      --rule-win: #7CFF99;      /* zöld */
      --rule-kill: #FF8080;     /* piros */
      --rule-special: #E0C3FF;  /* lila */
      --rule-night: #86B6FF;    /* sötétkék */
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: #000;
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      user-select: none;
    }
    #bg, #gameCanvas { position: fixed; inset: 0; display: block; }
    #bg { z-index: 0; } #gameCanvas { z-index: 1; }

    /* Bal felső panel */
    #ui {
      position: fixed; top: 14px; left: 14px; z-index: 3;
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 10px; padding: 10px 10px 12px;
      backdrop-filter: blur(6px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.35);
      max-width: min(560px, 90vw);
    }
    .row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
    .count { font-weight: 600; opacity: .9; }
    button {
      appearance: none; background: #1e1e1e;
      border: 1px solid var(--panel-border); color: var(--text);
      border-radius: 8px; padding: 8px 12px; cursor: pointer; font-weight: 600;
    }
    button:hover { background: #262626; } button:active { transform: translateY(1px); }

    .menu { margin-top: 8px; max-height: 0; overflow: hidden; transition: max-height 220ms ease; border-top: 1px solid transparent; }
    .menu.open { border-top-color: var(--panel-border); max-height: 1200px; }
    .grid {
      margin-top: 8px;
      display: grid; grid-template-columns: repeat(2, minmax(140px, 1fr));
      gap: 6px;
    }
    .chip {
      display: flex; align-items: center; justify-content: center;
      background: #141414; border: 1px solid var(--panel-border);
      padding: 8px 10px; border-radius: 999px; cursor: pointer; white-space: nowrap;
      font-size: 14px; line-height: 1;
    }
    .chip:hover { background: #1b1b1b; }
    .chip.disabled { color: #5d5d5d; border-color: rgba(255,255,255,0.06); background: #0f0f0f; cursor: not-allowed; filter: saturate(0.5); }

    /* Jobb alsó dokk */
    #dock {
      position: fixed; right: 14px; bottom: 14px; z-index: 4;
      display: flex; align-items: center; gap: 10px; flex-wrap: wrap; justify-content: flex-end;
    }
    #trash {
      width: 64px; height: 64px;
      background: rgba(20,20,20,0.85);
      border: 1px solid var(--panel-border);
      border-radius: 12px; display: grid; place-items: center; color: #fff;
      box-shadow: 0 6px 20px rgba(0,0,0,0.35);
      transition: transform .1s ease, background .2s ease, border-color .2s ease;
    }
    #trash.hot { background: rgba(200,40,40,0.9); border-color: rgba(255,255,255,0.35); transform: scale(1.05); }
    #trash svg { width: 28px; height: 28px; opacity: .9; }

    /* Körtánc! gomb */
    #danceBtn {
      position: fixed; top: 14px; left: 50%; transform: translateX(-50%);
      z-index: 5; padding: 14px 22px; font-size: 18px; letter-spacing: .3px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.35);
      background: #262626; transition: background .2s ease, transform .05s ease, box-shadow .2s ease;
    }
    #danceBtn:hover { background: #2e2e2e; }
    #danceBtn.pressed {
      background: #333; box-shadow: 0 0 0 2px rgba(255,255,255,0.08) inset;
      transform: translateX(-50%) translateY(1px);
    }

    /* ==== RULES UI ==== */
    #rulesToggleWrap {
      margin-top: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      opacity: 0.95;
    }
    #rulePanel {
      position: fixed;
      z-index: 6;
      max-width: min(520px, 94vw);
      background: rgba(15,15,20,0.96);
      border: 1px solid var(--panel-border);
      border-radius: 10px;
      box-shadow: 0 10px 24px rgba(0,0,0,0.45);
      padding: 12px 14px;
      line-height: 1.45;
      display: none;
      pointer-events: none;
    }
    #rulePanel h4 {
      margin: 0 0 6px 0; font-size: 14px; letter-spacing: .2px;
      color: var(--text);
    }
    .rule-item { margin: 6px 0; font-size: 13.5px; }
    .rule-emoji { margin-right: 8px; font-weight: 700; }
    .rule-win   { color: var(--rule-win); }
    .rule-kill  { color: var(--rule-kill); }
    .rule-special { color: var(--rule-special); }
    .rule-night { color: var(--rule-night); }

    /* ======= MOBIL LAYOUT FIX ======= */
    @media (max-width: 600px) {
      #ui {
        left: 8px; right: 8px; max-width: none; width: auto;
      }
      .grid { grid-template-columns: 1fr; } /* keskenyebb gombok egymás alatt */
      .menu.open { max-height: 48vh; overflow: auto; } /* menü görgethető */
      #danceBtn {
        top: auto; 
        bottom: calc(14px + env(safe-area-inset-bottom, 0px)); 
        left: 50%; 
        transform: translateX(-50%);
        padding: 12px 18px; font-size: 16px;
      }
      #dock {
        right: 8px;
        bottom: calc(90px + env(safe-area-inset-bottom, 0px)); /* ne takarja a Körtánc! gombot */
      }
    }
    /* iOS notch fallback (ha nincs env() támogatás, a calc második paramétere 0px lesz) */
  </style>
</head>
<body>
  <canvas id="bg"></canvas>
  <canvas id="gameCanvas"></canvas>

  <button id="danceBtn">Körtánc!</button>

  <div id="ui">
    <div class="row">
      <button id="addBtn">Karakter hozzáadása</button>
      <div id="playerCount" class="count">Játékosok száma: <span id="playerNum">0</span></div>
    </div>

    <!-- Szabályok mutatása kapcsoló -->
    <div id="rulesToggleWrap" class="row">
      <input type="checkbox" id="showRules" />
      <label for="showRules">Szabályok mutatása</label>
    </div>

    <div id="menu" class="menu">
      <div class="grid" id="charGrid"></div>
    </div>
  </div>

  <!-- Lebegő szabály-panel -->
  <div id="rulePanel" role="dialog" aria-live="polite"></div>

  <div id="dock">
    <div id="trash" title="Húzz ide karaktert a törléshez">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <path d="M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6" />
        <path d="M10 11v6M14 11v6" />
      </svg>
    </div>
    <button id="resetBtn" title="Minden törlése">Reset</button>
  </div>

  <script>
    /* ===== Vásznak és háttér ===== */
    const bg = document.getElementById('bg');
    const bgCtx = bg.getContext('2d');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    function sizeCanvases() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      bg.width = Math.floor(window.innerWidth * dpr);
      bg.height = Math.floor(window.innerHeight * dpr);
      bg.style.width = window.innerWidth + 'px';
      bg.style.height = window.innerHeight + 'px';
      bgCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
      drawBackground();

      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', sizeCanvases);

    function drawBackground() {
      const w = bg.width / (window.devicePixelRatio || 1);
      const h = bg.height / (window.devicePixelRatio || 1);
      bgCtx.clearRect(0, 0, w, h);
      bgCtx.fillStyle = '#000'; bgCtx.fillRect(0, 0, w, h);
      const grad = bgCtx.createRadialGradient(w/2, h/2, Math.min(w,h)*0.2, w/2, h/2, Math.max(w,h)*0.7);
      grad.addColorStop(0, 'rgba(255,255,255,0.03)'); grad.addColorStop(1, 'rgba(255,255,255,0)');
      bgCtx.fillStyle = grad; bgCtx.fillRect(0, 0, w, h);
      const spacing = 32, dot = 1.2;
      bgCtx.fillStyle = 'rgba(255,255,255,0.10)';
      for (let y = spacing/2; y < h; y += spacing) {
        for (let x = spacing/2; x < w; x += spacing) {
          bgCtx.beginPath(); bgCtx.arc(x, y, dot, 0, Math.PI*2); bgCtx.fill();
        }
      }
    }

    /* ===== Állapot ===== */
    const characters = [
      "Király","Királynő","Orgyilkos","Báró","Orvos","Pestises",
      "Térítő","Inkvizítor","Lovag","Rabló","Kereskedő","Pap",
      "Sírásó","Látnok","Bolond","Szektások","Gyíkkirály","Időutazó"
    ];

    const nodes = [];          // {id, name, x, y, radius, state}
    let connections = [];      // élő (közelség) kapcsolatok
    let renderEdges = [];      // amit épp rajzolunk
    const RADIUS = 32;
    const CONNECT_DISTANCE = 160;

    let dragNode = null;
    let mouse = {x:0, y:0};

    let isDanceMode = false;

    const addBtn = document.getElementById('addBtn');
    const danceBtn = document.getElementById('danceBtn');
    const menu = document.getElementById('menu');
    const charGrid = document.getElementById('charGrid');
    const trash = document.getElementById('trash');
    const resetBtn = document.getElementById('resetBtn');
    const playerNum = document.getElementById('playerNum');

    // kereskedő vizuális híd (a két összekötött szomszéd és a kereskedő id-ja)
    let traderBridge = null; // {aId, bId, tId, preExisted, inTriangle}

    function updatePlayerCount() { playerNum.textContent = nodes.length.toString(); }

    addBtn.addEventListener('click', () => { menu.classList.toggle('open'); refreshMenu(); });
    resetBtn.addEventListener('click', () => {
      nodes.length = 0; connections = []; renderEdges = [];
      isDanceMode = false; danceBtn.classList.remove('pressed');
      traderBridge = null;
      refreshMenu(); clearStates(); updatePlayerCount();
      clearRulePanel();
    });

    /* ===== Menü ===== */
    function baseName(name) { return name.startsWith('Szektás') ? 'Szektás' : name; }
    function existingBaseNames() { return new Set(nodes.map(n => baseName(n.name))); }

    function refreshMenu() {
      charGrid.innerHTML = '';
      const existing = existingBaseNames();
      characters.forEach(label => {
        const item = document.createElement('div');
        item.className = 'chip';
        item.textContent = label;
        const isSect = (label === 'Szektások');
        const disableCheckName = isSect ? 'Szektás' : label;
        const isDisabled = existing.has(disableCheckName);
        if (isDisabled) item.classList.add('disabled');
        if (!isDisabled) {
          item.addEventListener('click', () => {
            if (isSect) addSectGroupOnce(); else addCharacter(label);
            isDanceMode = false;
            danceBtn.classList.remove('pressed');
            renderEdges = [];
            traderBridge = null;
            clearStates();
            refreshMenu();
          });
        }
        charGrid.appendChild(item);
      });
    }

    /* ===== Spawn ===== */
    let autoId = 1;
    function centeredSpawnPosition() {
      const cw = canvas.width / (window.devicePixelRatio || 1);
      const ch = canvas.height / (window.devicePixelRatio || 1);
      const cx = cw / 2, cy = ch / 2;
      const jitter = 80;
      return { x: cx + (Math.random() - 0.5) * jitter * 2, y: cy + (Math.random() - 0.5) * jitter * 2 };
    }
    function addCharacter(name) {
      const pos = centeredSpawnPosition();
      nodes.push({ id: autoId++, name, x: pos.x, y: pos.y, radius: RADIUS, state: 'normal' });
      updatePlayerCount();
    }
    function addSectGroupOnce() {
      const pos = centeredSpawnPosition();
      const offset = 56;
      const pts = [ {x: pos.x, y: pos.y}, {x: pos.x + offset, y: pos.y + offset}, {x: pos.x - offset, y: pos.y + offset} ];
      for (let i = 0; i < 3; i++) nodes.push({ id: autoId++, name: `Szektás ${i+1}`, x: pts[i].x, y: pts[i].y, radius: RADIUS, state: 'normal' });
      updatePlayerCount();
    }

    /* ===== Drag & Drop + interakció ===== */
    function nodeAt(x, y) {
      for (let i = nodes.length - 1; i >= 0; i--) if (Math.hypot(nodes[i].x - x, nodes[i].y - y) <= nodes[i].radius) return nodes[i];
      return null;
    }
    canvas.addEventListener('mousedown', (e) => {
      const r = canvas.getBoundingClientRect(); const x = e.clientX - r.left; const y = e.clientY - r.top;
      mouse = {x, y}; dragNode = nodeAt(x, y);
      if (dragNode) { isDanceMode = false; danceBtn.classList.remove('pressed'); renderEdges = []; traderBridge = null; clearStates(); }
    });
    window.addEventListener('mousemove', (e) => {
      const r = canvas.getBoundingClientRect(); const x = e.clientX - r.left; const y = e.clientY - r.top;
      mouse = {x, y};
      if (dragNode) { dragNode.x = x; dragNode.y = y; }
      updateTrashHotClient(e.clientX, e.clientY);

      if (showRulesChk.checked) {
        const n = nodeAt(x, y);
        hoverRuleNodeId = n ? n.id : null;
      } else {
        hoverRuleNodeId = null;
      }
    });
    window.addEventListener('mouseup', (e) => {
      if (dragNode && isClientInTrash(e.clientX, e.clientY)) { deleteNode(dragNode); }
      dragNode = null; trash.classList.remove('hot');
    });

    // Mobil: tap to show/hide
    let touchMoved = false;
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const t = e.changedTouches[0];
      const r = canvas.getBoundingClientRect();
      const x = t.clientX - r.left, y = t.clientY - r.top;
      mouse = {x, y};
      dragNode = nodeAt(x, y);
      touchMoved = false;
      if (dragNode) { isDanceMode = false; danceBtn.classList.remove('pressed'); renderEdges = []; traderBridge = null; clearStates(); }
    }, {passive:false});

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      touchMoved = true;
      const t = e.changedTouches[0];
      const r = canvas.getBoundingClientRect();
      const x = t.clientX - r.left, y = t.clientY - r.top;
      mouse = {x, y};
      if (dragNode) { dragNode.x = x; dragNode.y = y; }
      updateTrashHotClient(t.clientX, t.clientY);
    }, {passive:false});

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      const t = e.changedTouches[0];
      const r = canvas.getBoundingClientRect();
      const x = t.clientX - r.left, y = t.clientY - r.top;

      if (showRulesChk.checked && !touchMoved) {
        const n = nodeAt(x, y);
        if (n) {
          selectedRuleNodeId = (selectedRuleNodeId === n.id) ? null : n.id;
        } else {
          selectedRuleNodeId = null;
        }
      }

      if (dragNode && isClientInTrash(t.clientX, t.clientY)) { deleteNode(dragNode); }
      dragNode = null; trash.classList.remove('hot');
    }, {passive:false});

    canvas.addEventListener('touchcancel', (e) => {
      e.preventDefault();
      dragNode = null; trash.classList.remove('hot');
    }, {passive:false});

    // Asztali kattintás: show/hide
    const showRulesChk = document.getElementById('showRules');
    const rulePanel = document.getElementById('rulePanel');
    let hoverRuleNodeId = null;
    let selectedRuleNodeId = null;

    canvas.addEventListener('click', (e) => {
      if (!showRulesChk.checked) return;
      const r = canvas.getBoundingClientRect();
      const x = e.clientX - r.left, y = e.clientY - r.top;
      const n = nodeAt(x, y);
      if (n) selectedRuleNodeId = (selectedRuleNodeId === n.id) ? null : n.id;
      else selectedRuleNodeId = null;
    });

    // Kívül kattintva zárás
    document.addEventListener('click', (e) => {
      if (!showRulesChk.checked) return;
      const withinUI = e.target.closest('#ui') || e.target.closest('#rulePanel') || e.target === canvas;
      if (!withinUI) selectedRuleNodeId = null;
    });

    function isClientInTrash(clientX, clientY) {
      const rect = trash.getBoundingClientRect();
      return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
    }
    function updateTrashHotClient(clientX, clientY) {
      if (dragNode && isClientInTrash(clientX, clientY)) trash.classList.add('hot');
      else trash.classList.remove('hot');
    }
    function deleteNode(node) {
      const bn = baseName(node.name);
      if (bn === 'Szektás') {
        for (let i = nodes.length - 1; i >= 0; i--) if (baseName(nodes[i].name) === 'Szektás') nodes.splice(i, 1);
      } else {
        const idx = nodes.findIndex(n => n.id === node.id);
        if (idx !== -1) nodes.splice(idx, 1);
      }
      connections = []; renderEdges = []; isDanceMode = false; danceBtn.classList.remove('pressed');
      traderBridge = null;
      clearStates(); updatePlayerCount(); refreshMenu();
    }

    /* ===== Kapcsolatok (élő) ===== */
    function updateConnections() {
      const edges = [];
      const deg = new Map(nodes.map(n => [n.id, 0]));
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const a = nodes[i], b = nodes[j];
          const d = Math.hypot(a.x - b.x, a.y - b.y);
          if (d <= CONNECT_DISTANCE) {
            if (deg.get(a.id) < 2 && deg.get(b.id) < 2) {
              edges.push([a.id, b.id]);
              deg.set(a.id, deg.get(a.id) + 1);
              deg.set(b.id, deg.get(b.id) + 1);
            }
          }
        }
      }
      connections = edges;
    }

    /* ===== Segédfüggvények ===== */
    function clearStates() { nodes.forEach(n => n.state = 'normal'); }
    function idToNode(id) { return nodes.find(n => n.id === id); }
    function findByBase(label) { return nodes.find(n => baseName(n.name) === label); }
    function buildAdj(edges) {
      const adj = new Map(nodes.map(n => [n.id, new Set()]));
      edges.forEach(([a,b]) => { adj.get(a).add(b); adj.get(b).add(a); });
      return adj;
    }
    function isConnected(adj, aId, bId) {
      if (!aId || !bId) return false;
      const s = adj.get(aId);
      return s ? s.has(bId) : false;
    }
    function neighbors(adj, id) { return Array.from(adj.get(id) || []); }

    function getComponents(adj) {
      const seen = new Set(), comps = [];
      for (const n of nodes) {
        if (seen.has(n.id)) continue;
        const q = [n.id]; const comp = []; seen.add(n.id);
        while (q.length) {
          const v = q.shift(); comp.push(v);
          for (const w of adj.get(v)) if (!seen.has(w)) { seen.add(w); q.push(w); }
        }
        comps.push(comp);
      }
      return comps;
    }

    /* ===== Lánczárás (tiltott él opcióval) ===== */
    function closeChainEndsOnce(edges, forbidPair) {
      const E = edges.slice();
      const A = buildAdj(E);
      const seen = new Set();
      const forbidSet = forbidPair
        ? new Set([`${forbidPair.u}|${forbidPair.v}`, `${forbidPair.v}|${forbidPair.u}`])
        : null;

      for (const n of nodes) {
        if (seen.has(n.id)) continue;
        const q = [n.id], comp = [];
        seen.add(n.id);
        while (q.length) {
          const v = q.shift(); comp.push(v);
          for (const w of A.get(v)) if (!seen.has(w)) { seen.add(w); q.push(w); }
        }
        if (comp.length >= 3) {
          const ends = comp.filter(id => (A.get(id) || new Set()).size === 1);
          if (ends.length === 2) {
            const [e1, e2] = ends;
            if (forbidSet && forbidSet.has(`${e1}|${e2}`)) continue;
            if (!(A.get(e1) && A.get(e1).has(e2))) {
              E.push([e1, e2]);
              A.get(e1).add(e2); A.get(e2).add(e1);
            }
          }
        }
      }
      return E;
    }

    /* ===== Kizáródás (force-include) ===== */
    function excludedFromAdj(adj, forceInclude = null) {
      const set = new Set();
      nodes.forEach(n => {
        const deg = (adj.get(n.id) || new Set()).size;
        const keep = forceInclude && forceInclude.has(n.id);
        if (deg < 2 && !keep) set.add(n.id);
      });
      return set;
    }

    /* ===== Körtánc kiértékelés ===== */
    function evaluateDance() {
      danceBtn.classList.add('pressed');

      // 1) Élő kapcsolatok + lánczárás
      updateConnections();
      let edgesClosed = connections.slice();
      let adjClosed = buildAdj(edgesClosed);

      const visited = new Set();
      const toClose = [];
      for (const n of nodes) {
        if (visited.has(n.id)) continue;
        const q = [n.id]; const comp = []; visited.add(n.id);
        while (q.length) {
          const v = q.shift(); comp.push(v);
          for (const w of adjClosed.get(v)) if (!visited.has(w)) { visited.add(w); q.push(w); }
        }
        if (comp.length >= 3) {
          const ends = comp.filter(id => adjClosed.get(id).size === 1);
          if (ends.length === 2) toClose.push(ends);
        }
      }
      for (const [e1, e2] of toClose) edgesClosed.push([e1, e2]);
      adjClosed = buildAdj(edgesClosed);

      // 2) Kereskedő – kilépés + híd
      const trader = findByBase('Kereskedő');
      traderBridge = null;
      let edgesNoBridge = edgesClosed.slice();
      let edgesWithBridge = edgesClosed.slice();
      if (trader) {
        const nb = neighbors(adjClosed, trader.id);
        if (nb.length === 2) {
          const [aId, bId] = nb;
          edgesNoBridge = edgesNoBridge.filter(([x,y]) => x !== trader.id && y !== trader.id);
          edgesWithBridge = edgesWithBridge.filter(([x,y]) => x !== trader.id && y !== trader.id);
          const preExisted = isConnected(adjClosed, aId, bId);

          const inTriangle =
            isConnected(adjClosed, aId, trader.id) &&
            isConnected(adjClosed, bId, trader.id) &&
            isConnected(adjClosed, aId, bId);

          if (!preExisted) edgesWithBridge.push([aId, bId]);
          traderBridge = { aId, bId, tId: trader.id, preExisted, inTriangle };
        }
      }

      // 3) Lánczárás a két világban
      let forbid = null;
      if (traderBridge && !traderBridge.preExisted) {
        forbid = { u: traderBridge.aId, v: traderBridge.bId };
      }
      edgesNoBridge   = closeChainEndsOnce(edgesNoBridge, forbid);
      edgesWithBridge = closeChainEndsOnce(edgesWithBridge);

      const adjNo   = buildAdj(edgesNoBridge);
      const adjWith = buildAdj(edgesWithBridge);

      let force = null;
      if (traderBridge && !traderBridge.preExisted) {
        force = new Set([traderBridge.aId, traderBridge.bId]);
      }
      const excludedNo   = excludedFromAdj(adjNo,   force);

      let forceWith = null;
      if (traderBridge && traderBridge.inTriangle) {
        forceWith = new Set([traderBridge.aId, traderBridge.bId]);
      }
      const excludedWith = excludedFromAdj(adjWith, forceWith);

      function makeIsProtectedByDoctor(adj, excluded, considerDoctor) {
        const doctor = findByBase('Orvos');
        const plague = findByBase('Pestises');
        return function(victimId) {
          if (!considerDoctor) return false;
          if (!doctor || excluded.has(doctor.id)) return false;
          const docPlagueSpecial = (plague && !excluded.has(plague.id) && isConnected(adj, doctor.id, plague.id));
          if (docPlagueSpecial) return victimId === plague.id;
          return isConnected(adj, doctor.id, victimId);
        };
      }

      // ★ MOD: segédfüggvény a Pap „most nyerne?” ellenőrzéséhez (Rabló előtt kell)
      function priestWouldWin(adj, excluded) { // ★ MOD
        const priest = findByBase('Pap');      // ★ MOD
        if (!priest || excluded.has(priest.id)) return false; // ★ MOD
        const comps = getComponents(adj);      // ★ MOD
        const cycles = comps.filter(comp =>    // ★ MOD
          comp.length >= 3 && comp.every(id => (adj.get(id) || new Set()).size === 2)
        );                                     // ★ MOD
        let maxSize = 0, countMax = 0, priestInMax = false; // ★ MOD
        cycles.forEach(comp => {               // ★ MOD
          if (comp.length > maxSize) { maxSize = comp.length; countMax = 1; priestInMax = comp.includes(priest.id); }
          else if (comp.length === maxSize) { countMax++; if (comp.includes(priest.id)) priestInMax = true; }
        });                                     // ★ MOD
        return (maxSize > 0 && countMax === 1 && priestInMax); // ★ MOD
      }                                         // ★ MOD

      function resolveRoundOn(adj, excluded, considerDoctor) {
        const doctor = findByBase('Orvos');
        const plague = findByBase('Pestises');
        const king = findByBase('Király');
        const assassin = findByBase('Orgyilkos');
        const baron = findByBase('Báró');
        const queen = findByBase('Királynő');
        const gravedigger = findByBase('Sírásó');
        const preacher = findByBase('Térítő');
        const inquisitor = findByBase('Inkvizítor');
        const knight = findByBase('Lovag');
        const robber = findByBase('Rabló');
        const priest = findByBase('Pap');
        const lizard = findByBase('Gyíkkirály');

        const isProt = makeIsProtectedByDoctor(adj, excluded, considerDoctor);

        const winners = new Set();
        const deaths = new Set();
        const alive = (n) => n && !excluded.has(n.id);

        const preacherBlocked = (preacher && inquisitor && alive(preacher) && alive(inquisitor) && isConnected(adj, preacher.id, inquisitor.id));

        const killerVictims = new Map();
        const selfDeaths = new Set();
        const pushIntent = (k, v) => { if (!killerVictims.has(k)) killerVictims.set(k, new Set()); killerVictims.get(k).add(v); };

        // Orgyilkos -> Király
        if (king && assassin && alive(king) && alive(assassin) && isConnected(adj, king.id, assassin.id)) {
          pushIntent(assassin.id, king.id);
        }
        // Orgyilkos -> Gyíkkirály (nem ad nyerést az orgyilkosnak)
        if (lizard && assassin && alive(lizard) && alive(assassin) && isConnected(adj, lizard.id, assassin.id)) {
          pushIntent(assassin.id, lizard.id);
        }

        // Inkvizítor -> Térítő
        if (preacher && inquisitor && alive(preacher) && alive(inquisitor) && isConnected(adj, preacher.id, inquisitor.id)) {
          pushIntent(inquisitor.id, preacher.id);
        }

        // Pestises
        if (plague && alive(plague)) {
          const nbs = neighbors(adj, plague.id);
          const docPlagueSpecial = considerDoctor && doctor && alive(doctor) && isConnected(adj, doctor.id, plague.id);
          if (docPlagueSpecial) {
            if (alive(doctor)) pushIntent(plague.id, doctor.id);
          } else {
            nbs.forEach(v => { if (!excluded.has(v)) pushIntent(plague.id, v); });
            selfDeaths.add(plague.id);
          }
        }

        // Gyíkkirály – megöli a szomszédait
        if (lizard && alive(lizard)) {
          const nbs = neighbors(adj, lizard.id);
          nbs.forEach(v => { if (!excluded.has(v)) pushIntent(lizard.id, v); });
        }

        /* LOVAG megelőzés */
        const preventedKillers = new Set();
        let knightPreventedTotal = 0;
        const killerIds = Array.from(killerVictims.keys());
        if (knight && alive(knight)) {
          killerIds.forEach(kid => {
            if (isConnected(adj, knight.id, kid) && killerVictims.get(kid).size > 0) {
              preventedKillers.add(kid);
              knightPreventedTotal++;
            }
          });
        }

        /* HALÁLOK + orgyilkos jelző */
        let assassinKillSucceeded = false;
        selfDeaths.forEach(id => deaths.add(id));
        for (const [kid, victims] of killerVictims.entries()) {
          for (const vid of victims) {
            if (preventedKillers.has(kid)) continue;
            if (excluded.has(vid)) continue;
            if (isProt(vid)) continue;
            if (assassin && king && kid === assassin.id && vid === king.id) {
              assassinKillSucceeded = true;
            }
            deaths.add(vid);
          }
        }
        for (const kid of preventedKillers) {
          if (!isProt(kid)) deaths.add(kid);
        }

        /* Szektások */
        (function applySects() {
          const sectIds = nodes.filter(n => baseName(n.name) === 'Szektás').map(n => n.id);
          if (sectIds.length !== 3) return;

          const comps = getComponents(adj);
          const cycles = comps.filter(comp => comp.every(id => (adj.get(id) || new Set()).size === 2));
          const targetCycle = cycles.find(comp => comp.length >= 4 && sectIds.every(id => comp.includes(id)));
          if (!targetCycle) return;

          const [s1, s2, s3] = sectIds;
          const triples = [[s1,s2,s3],[s2,s3,s1],[s3,s1,s2]];
          let consecutive = null;
          for (const [a,b,c] of triples) {
            if (isConnected(adj,a,b) && isConnected(adj,b,c) && !isConnected(adj,a,c)) { consecutive = [a,b,c]; break; }
          }
          if (!consecutive) return;

          if (knight && alive(knight) && sectIds.some(id => isConnected(adj, knight.id, id))) {
            const target = sectIds.find(id => isConnected(adj, knight.id, id));
            if (target && !isProt(target)) deaths.add(target);
            knightPreventedTotal++;
            return;
          }

          for (const vid of targetCycle) {
            if (!sectIds.includes(vid) && !excluded.has(vid) && !isProt(vid)) deaths.add(vid);
          }
          sectIds.forEach(id => { const n = idToNode(id); if (n && !excluded.has(id) && !deaths.has(id)) winners.add(id); });
        })();

        /* Alap-nyerések (Rabló előtt) */
        const isAliveFinal = (n) => n && !excluded.has(n.id) && !deaths.has(n.id);
        const kingDead = king ? (!excluded.has(king.id) && deaths.has(king.id)) : false;
        const kingExcluded = king ? excluded.has(king.id) : false;
        const kingGone = kingDead || kingExcluded;

        const lizardDeadNow = lizard ? (!excluded.has(lizard.id) && deaths.has(lizard.id)) : false;

        if (isAliveFinal(king) && !lizardDeadNow) winners.add(king.id);
        if (assassin && isAliveFinal(assassin) && assassinKillSucceeded) winners.add(assassin.id);
        if (isAliveFinal(baron) && kingGone && !lizardDeadNow) winners.add(baron.id);

        if (queen && isAliveFinal(queen)) {
          const qk = !lizardDeadNow && king && isAliveFinal(king) && isConnected(adj, queen.id, king.id);
          const qb = !lizardDeadNow && kingGone && baron && isAliveFinal(baron) && isConnected(adj, queen.id, baron.id);
          const qL = lizardDeadNow && lizard && !excluded.has(lizard.id) && isConnected(adj, queen.id, lizard.id);
          if (qk || qb || qL) winners.add(queen.id);
        }

        if (plague && isAliveFinal(plague) && considerDoctor && doctor && !excluded.has(doctor.id) && isConnected(adj, doctor.id, plague.id)) winners.add(plague.id);
        if (gravedigger && isAliveFinal(gravedigger)) {
          const gNeighbors = neighbors(adj, gravedigger.id);
          if (gNeighbors.some(id => deaths.has(id) && !excluded.has(id))) winners.add(gravedigger.id);
        }
        if (inquisitor && preacher && isAliveFinal(inquisitor) && !excluded.has(preacher.id) && isConnected(adj, inquisitor.id, preacher.id)) winners.add(inquisitor.id);
        if (preacher && !preacherBlocked && !excluded.has(preacher.id) && (adj.get(preacher.id) || new Set()).size === 2) {
          const nb = neighbors(adj, preacher.id);
          if (nb.length === 2 && isConnected(adj, nb[0], nb[1])) { winners.add(preacher.id); winners.add(nb[0]); winners.add(nb[1]); }
        }

        /* RABLÓ – ★ MOD: Pap és „megelőzéses” Lovag kezelése is */
        if (robber && isAliveFinal(robber)) {
          const nb = neighbors(adj, robber.id);

          const willNoOneDie = deaths.size === 0;
          const robberNoDeathTriggerTargets = [];
          if (willNoOneDie) {
            const dOK = doctor && isAliveFinal(doctor) && nb.includes(doctor.id);
            const kOK = knight && isAliveFinal(knight) && nb.includes(knight.id);
            if (dOK) robberNoDeathTriggerTargets.push(doctor.id);
            if (kOK) robberNoDeathTriggerTargets.push(knight.id);
          }

          // ★ MOD: a Pap nyerésének előrejelzése (még a winners-be kerülés előtt)
          const priestWinsNow = priestWouldWin(adj, excluded) && priest && isAliveFinal(priest); // ★ MOD

          const robberTargets = nb.filter(id => {
            const n = idToNode(id); if (!n) return false;
            if (baseName(n.name) === 'Király') return false;
            if (deaths.has(id)) return false;
            if (baseName(n.name) === 'Pap') {          // ★ MOD
              return priestWinsNow;                    // ★ MOD
            }
            return winners.has(id);
          });

          const targetsSet = new Set(robberTargets.concat(robberNoDeathTriggerTargets));

          // ★ MOD: ha a Lovag megelőzés miatt nyerne, a Rabló „célpontnak” tekinti → Lovag megakadályozza és megöli a Rablót
          const knightWouldWinByPrevention = knight && isAliveFinal(knight) && knightPreventedTotal > 0; // ★ MOD
          if (knightWouldWinByPrevention && nb.includes(knight.id)) targetsSet.add(knight.id);          // ★ MOD

          let robberPrevented = false;
          if (knight && isAliveFinal(knight) && isConnected(adj, knight.id, robber.id) && targetsSet.size > 0) {
            robberPrevented = true;
            knightPreventedTotal++;
          }

          let robberKilledAny = false;
          for (const tid of targetsSet) {
            if (robberPrevented) continue;
            if (isProt(tid)) continue;
            const tn = idToNode(tid);
            if (tn && baseName(tn.name) === 'Lovag') continue; // Lovagot nem tudja megölni
            deaths.add(tid);
            robberKilledAny = true;
          }
          if (robberPrevented) {
            if (!isProt(robber.id)) deaths.add(robber.id);
          }
          if (robberKilledAny && isAliveFinal(robber)) winners.add(robber.id);
        }

        // Lovag győzelem
        if (knight && isAliveFinal(knight) && knightPreventedTotal > 0) winners.add(knight.id);
        if (knight && isAliveFinal(knight) && knightPreventedTotal === 0 && deaths.size === 0) winners.add(knight.id);

        // Pap – legnagyobb zárt kör (eredeti helyén marad)
        if (priest && isAliveFinal(priest)) {
          const comps = getComponents(adj);
          const cycles = comps.filter(comp => comp.length >= 3 && comp.every(id => (adj.get(id) || new Set()).size === 2));
          let maxSize = 0, countMax = 0, priestInMax = false;
          cycles.forEach(comp => {
            if (comp.length > 0 && comp.length > maxSize) { maxSize = comp.length; countMax = 1; priestInMax = comp.includes(priest.id); }
            else if (comp.length === maxSize) { countMax++; if (comp.includes(priest.id)) priestInMax = true; }
          });
          if (maxSize > 0 && countMax === 1 && priestInMax) winners.add(priest.id);
        }

        // Gyíkkirály: ha meghalt → nyer
        if (lizard && deaths.has(lizard.id) && !excluded.has(lizard.id)) {
          winners.add(lizard.id);
        }

        return { deaths, winners };
      }

      const withDoc         = resolveRoundOn(adjWith, excludedWith, true);
      const noDoc           = resolveRoundOn(adjWith, excludedWith, false);
      const withDocNoBridge = resolveRoundOn(adjNo,   excludedNo,   true);

      // ★ MOD: segédfüggvény — „nélküle is nyernek a Szektások?” (NO-BRIDGE világon)
      function sectsAutoWinOn(adj, excluded) {                                 // ★ MOD
        const sectIds = nodes.filter(n => baseName(n.name) === 'Szektás').map(n => n.id); // ★ MOD
        if (sectIds.length !== 3) return false;                                 // ★ MOD
        const comps = getComponents(adj);                                       // ★ MOD
        const cycles = comps.filter(comp => comp.every(id => (adj.get(id) || new Set()).size === 2)); // ★ MOD
        const targetCycle = cycles.find(comp => comp.length >= 4 && sectIds.every(id => comp.includes(id))); // ★ MOD
        if (!targetCycle) return false;                                         // ★ MOD
        const [s1,s2,s3] = sectIds;                                            // ★ MOD
        const triples = [[s1,s2,s3],[s2,s3,s1],[s3,s1,s2]];                     // ★ MOD
        let consecutive = false;                                                // ★ MOD
        for (const [a,b,c] of triples) {                                        // ★ MOD
          if (isConnected(adj,a,b) && isConnected(adj,b,c) && !isConnected(adj,a,c)) { consecutive = true; break; } // ★ MOD
        }                                                                        // ★ MOD
        if (!consecutive) return false;                                         // ★ MOD
        // legyen a körben más is (>=4 hosszú ciklust már szűrtük)                // ★ MOD
        return true;                                                            // ★ MOD
      }                                                                          // ★ MOD

// --- Tiszta "no-trader" világ a szektások viszonyításához (nem tiltjuk a lezárást) --- // ★ FIX
let adjNoPure = null, excludedNoPure = null;                                       // ★ FIX
if (trader) {                                                                      // ★ FIX
  const edgesNoTrader = edgesClosed.filter(([x,y]) => x !== trader.id && y !== trader.id); // ★ FIX
  const edgesNoTraderClosed = closeChainEndsOnce(edgesNoTrader);                   // ★ FIX
  adjNoPure = buildAdj(edgesNoTraderClosed);                                       // ★ FIX
  excludedNoPure = excludedFromAdj(adjNoPure);                                     // ★ FIX
}                

      let traderWins = false;
      if (traderBridge && !traderBridge.preExisted) {
        const { aId, bId } = traderBridge;
        const aAliveWith = !withDoc.deaths.has(aId) && withDoc.winners.has(aId);
        const bAliveWith = !withDoc.deaths.has(bId) && withDoc.winners.has(bId);
        const aAliveNo   = !withDocNoBridge.deaths.has(aId) && withDocNoBridge.winners.has(aId);
        const bAliveNo   = !withDocNoBridge.deaths.has(bId) && withDocNoBridge.winners.has(bId);
        if ((aAliveWith && !aAliveNo) || (bAliveWith && !bAliveNo)) traderWins = true;

        // ★ MOD: Szektás–ártatlan híd kivétel: ha híd nélkül is auto-win a Szektások → Kereskedő NE nyerjen
        const aIsSect = baseName(idToNode(aId)?.name || '') === 'Szektás';     // ★ MOD
        const bIsSect = baseName(idToNode(bId)?.name || '') === 'Szektás';     // ★ MOD
        const mixedSectBridge = (aIsSect && !bIsSect) || (!aIsSect && bIsSect); // ★ MOD
  if (mixedSectBridge) {                                        // ★ FIX
  const autoWinBaseline = adjNoPure ?                         // ★ FIX
    sectsAutoWinOn(adjNoPure, excludedNoPure) : false;        // ★ FIX
  if (autoWinBaseline) traderWins = false;                    // ★ FIX
}                                                             // ★ FIX
                                                      // ★ MOD
      }

      clearStates();

      const excludedFinal = new Set(excludedWith);
      const traderNode = findByBase('Kereskedő');
      if (traderNode) excludedFinal.delete(traderNode.id);

      nodes.forEach(n => { if (excludedFinal.has(n.id)) n.state = 'excluded'; });

      const deathsFinal = new Set(withDoc.deaths);
      if (traderNode) deathsFinal.delete(traderNode.id);
      nodes.forEach(n => { if (n.state !== 'excluded' && deathsFinal.has(n.id)) n.state = 'dead'; });

      nodes.forEach(n => { if (withDoc.winners.has(n.id) && n.state === 'normal') n.state = 'winner'; });

      const doctor = findByBase('Orvos');
      if (doctor && doctor.state === 'normal') {
        const docNbs = neighbors(adjWith, doctor.id);
        let saved = 0;
        for (const nb of docNbs) {
          if (noDoc.deaths.has(nb) && !withDoc.deaths.has(nb)) saved++;
        }
        if (saved > 0 || withDoc.deaths.size === 0) doctor.state = 'winner';
      }

      const lizardNode = findByBase('Gyíkkirály');
      if (lizardNode) {
        const lid = lizardNode.id;
        if (withDoc.deaths.has(lid) && withDoc.winners.has(lid)) {
          lizardNode.state = 'lizard_dead_winner';
        }
      }

      if (traderNode) {
        if (traderWins) {
          traderNode.state = 'winner';
        } else {
          if (traderBridge) {
            const a = idToNode(traderBridge.aId);
            const b = idToNode(traderBridge.bId);
            const isPurpleTrigger = (n) => n && n.state === 'maybe' && (baseName(n.name) === 'Bolond' || baseName(n.name) === 'Időutazó');
            if (isPurpleTrigger(a) || isPurpleTrigger(b)) traderNode.state = 'maybe';
          }
        }
      }

      const maybeSet = new Set(['Bolond','Látnok','Időutazó']);
      nodes.forEach(n => {
        if (maybeSet.has(baseName(n.name)) && n.state === 'normal') n.state = 'maybe';
      });

      renderEdges = edgesWithBridge.slice();
      isDanceMode = true;
    }

    document.getElementById('danceBtn').addEventListener('click', evaluateDance);

    /* ===== RULES DATA (pontosan a megadott szövegek) ===== */
    const RULES = {
      "Király": [
        {type:"night", text:"Felfedi magát a játék elején."},
        {type:"win", text:"Nyer, ha túléli a játékot."}
      ],
      "Királynő": [
        {type:"win", text:"Nyer, ha annak az embernek a kezét fogja, aki a játék végén a király lesz."}
      ],
      "Báró": [
        {type:"night", text:"Megnézik egymást az Orgyilkossal."},
        {type:"special", text:"Ha a Király meghal, vagy kizáródik, a Báró lesz az új király."},
        {type:"win", text:"Nyer, ha ő lesz az új király."}
      ],
      "Orgyilkos": [
        {type:"night", text:"Megnézik egymást a Báróval."},
        {type:"kill", text:"Ha a Király kezét fogja, megöli."},
        {type:"win", text:"Nyer, ha megöli a Királyt."}
      ],
      "Orvos": [
        {type:"special", text:"Azok, akik az Orvos kezét fogják, nem halhatnak meg."},
        {type:"win", text:"Nyer, ha megment legalább egy embert, vagy ha nem hal meg senki a körében."}
      ],
      "Pestises": [
        {type:"kill", text:"A játék végén meghal, és megöli a két mellette állót."},
        {type:"win", text:"Nyer, ha az Orvos mellett áll, így nem hal meg."}
      ],
      "Térítő": [
        {type:"special", text:"Ha a játék végén egy három fős körben áll, mindkét mellette álló embert Követővé változtatja, akik elvesztik eredeti céljukat, és együtt nyernek, ha a játék végén egy hármas kört alkotnak."},
        {type:"win", text:"Nyer, ha három fős körben áll."}
      ],
      "Inkvizítor": [
        {type:"special", text:"A Nappal folyamán egyszer fölfedheti karakterkártyáját, hogy a másik fél beleegyezése nélkül megfoghassa annak szabad kezét."},
        {type:"kill", text:"Ha a játék végén a Térítő kezét fogja, megöli, megakadályozva a képességét."},
        {type:"win", text:"Nyer, ha megöli a Térítőt."}
      ],
      "Szektás": [
        {type:"kill", text:"Ha hárman egymás mellett állnak, mindenkit megölnek a körükben magukon kívül."},
        {type:"win", text:"Nyernek, ha legalább egy embert megölnek."}
      ],
      "Kereskedő": [
        {type:"special", text:"A Napnyugta fázis kezdetén kiáll a körből, és összeköti a két mellette állót."},
        {type:"win", text:"Nyer, ha kettejük közül legalább az egyik nyer az így létrejött kézfogás által."}
      ],
      "Lovag": [
        {type:"kill", text:"Ha olyan ember kezét fogja, aki megölne valakit, azt a képessége végrehajtása előtt megöli."},
        {type:"win", text:"Nyer, ha megakadályoz egy gyilkosságot, vagy ha nem hal meg senki."}
      ],
      "Pap": [
        {type:"win", text:"Nyer, ha a legnagyobb kialakult körben áll."}
      ],
      "Sírásó": [
        {type:"win", text:"Nyer, ha megfogja legalább egy olyan ember kezét, aki meghal."}
      ],
      "Látnok": [
        {type:"night", text:"Megnéz két titkos karakterkártyát."},
        {type:"win", text:"Nyer, ha a játék végén a két ember, akiknek megnézte a kártyáját, kezet fognak."}
      ],
      "Rabló": [
        {type:"kill", text:"Ha olyan ember kezét fogja, aki nyerne, azt megöli (kivéve a Királyt)."},
        {type:"win", text:"Nyer, ha legalább egy embert megöl."}
      ],
      "Bolond": [
        {type:"night", text:"Megnéz egy titkos karakterkártyát."},
        {type:"win", text:"Nyer, ha a játék végén olyan helyen áll, ahol a megnézett karakter nyerne (a képességeit nem kapja meg)."}
      ],
      "Időutazó": [
        {type:"win", text:"Nyer, ha a játék végén legalább egy olyan karakter kezét fogja, aki az előző játékban nyert."}
      ],
      "Gyíkkirály": [
        {type:"special", text:"Ha a Gyíkkirály játékban van, az Előkészületek elején az asztal közepére kell helyezni egy második Király lapot felfordítva. Ebben az esetben a Király nem fedi fel magát az Éjszaka fázis előtt."},
        {type:"night", text:"Az Éjszaka elején felkel a Király és a Gyíkkirály. A Gyíkkirály kicseréli lapját a második Király lappal, a Király pedig felfordítja a magáét."},
        {type:"special", text:"Úgy hat rá minden képesség, mint ahogy a Királyra hatna."},
        {type:"kill", text:"A Gyíkkirály megöli a mellette állókat."},
        {type:"win", text:"Nyer, ha meghal. Ez esetben mindenképpen ő lesz a király."}
      ]
    };

    const EMOJI = { win:"⭐", kill:"🔪", night:"🌙", special:"⚡" };
    function ruleHtmlFor(name) {
      const b = baseName(name);
      const arr = RULES[b];
      if (!arr) return "";
      const lines = arr.map(item => {
        const cls = `rule-item rule-${item.type}`;
        const emoji = EMOJI[item.type] || "";
        return `<div class="${cls}"><span class="rule-emoji">${emoji}</span>${item.text}</div>`;
      });
      return lines.join("");
    }
    function showRulePanelForNode(node) {
      if (!node) { clearRulePanel(); return; }
      const html = ruleHtmlFor(node.name);
      if (!html) { clearRulePanel(); return; }
      rulePanel.innerHTML = `<h4>${node.name}</h4>${html}`;
      const offset = 16;
      let px = node.x + offset;
      let py = node.y + offset;
      rulePanel.style.display = 'block';
      const maxW = Math.min(520, window.innerWidth * 0.94);
      const h = rulePanel.offsetHeight || 1;
      if (px + maxW > window.innerWidth - 10) px = window.innerWidth - maxW - 10;
      if (py + h > window.innerHeight - 10) py = window.innerHeight - h - 10;
      rulePanel.style.left = px + 'px';
      rulePanel.style.top  = py + 'px';
    }
    function clearRulePanel() { rulePanel.style.display = 'none'; rulePanel.innerHTML = ''; }

    /* ===== Rajzolás ===== */
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.lineWidth = 6;
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--line').trim() || '#fff';
      ctx.globalAlpha = 0.95;
      renderEdges.forEach(([aId, bId]) => {
        const a = idToNode(aId), b = idToNode(bId); if (!a || !b) return;
        ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
      });
      ctx.globalAlpha = 1;

      if (traderBridge) {
        const a = idToNode(traderBridge.aId);
        const b = idToNode(traderBridge.bId);
        const t = idToNode(traderBridge.tId);
        if (a && b && t) {
          const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
          ctx.lineWidth = 2;
          ctx.strokeStyle = 'rgba(255,255,255,0.6)';
          ctx.beginPath(); ctx.moveTo(t.x, t.y); ctx.lineTo(mx, my); ctx.stroke();
        }
      }

      nodes.forEach(n => {
        let fill = getComputedStyle(document.documentElement).getPropertyValue('--node-normal').trim() || '#fff';
        if (n.state === 'winner') fill = getComputedStyle(document.documentElement).getPropertyValue('--node-winner').trim() || '#39d353';
        else if (n.state === 'dead') fill = getComputedStyle(document.documentElement).getPropertyValue('--node-dead').trim() || '#ff4d4f';
        else if (n.state === 'excluded') fill = getComputedStyle(document.documentElement).getPropertyValue('--node-excl').trim() || '#9e9e9e';
        else if (n.state === 'maybe') fill = getComputedStyle(document.documentElement).getPropertyValue('--node-maybe').trim() || '#d5b8ff';
        else if (n.state === 'lizard_dead_winner') fill = getComputedStyle(document.documentElement).getPropertyValue('--node-winner').trim() || '#39d353';

        ctx.beginPath(); ctx.arc(n.x, n.y, n.radius + 6, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.10)'; ctx.fill();

        ctx.beginPath(); ctx.arc(n.x, n.y, n.radius, 0, Math.PI * 2);
        ctx.fillStyle = fill; ctx.fill();
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--node-stroke').trim() || '#111';
        ctx.lineWidth = 2; ctx.stroke();

        ctx.font = '13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillStyle = '#111'; ctx.fillText(n.name, n.x, n.y);
      });

      // Szabály-panel frissítés (hover > kiválasztott)
      if (showRulesChk.checked) {
        const node = hoverRuleNodeId ? idToNode(hoverRuleNodeId)
                    : (selectedRuleNodeId ? idToNode(selectedRuleNodeId) : null);
        showRulePanelForNode(node);
      } else {
        clearRulePanel();
      }
    }

    function loop() {
      updateConnections();
      if (!isDanceMode) renderEdges = connections.slice();
      draw();
      requestAnimationFrame(loop);
    }

    // init
    sizeCanvases();
    refreshMenu();
    updatePlayerCount();
    loop();
  </script>
</body>
</html>
